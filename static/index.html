<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="canonical" href="https://nobody.live" />

    <link rel="apple-touch-icon" sizes="180x180" href="/static/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/static/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/static/favicon-16x16.png">
    <link rel="manifest" href="/static/site.webmanifest">
    <link rel="mask-icon" href="/static/safari-pinned-tab.svg" color="#6441a5">
    <meta name="msapplication-TileColor" content="#6441a5">
    <meta name="theme-color" content="#6441a5">

    <meta property="og:title" content="Watch streamers with no audience">
    <meta property="og:site_name" content="Nobody.Live">
    <meta property="og:url" content="https://nobody.live/">
    <meta property="og:description" content="Become the entire audience of a lonely streamer broadcasting to zero viewers">
    <meta property="og:type" content="website">
    <meta property="og:image" content="https://nobody.live/static/og.jpg">

    <meta name="title" content="Nobody.Live -- Lonely Streams with No Audience">
    <meta name="description" content="Become the entire audience of a lonely streamer broadcasting to zero viewers">
    <meta name="keywords" content="stream, no viewers stream, streams with no audience, twitch no viewers">
    <meta name="robots" content="index, follow">
    <meta name="language" content="English">
    <meta name="author" content="Jack Kingsman">

    <title>Nobody.live | Lonely streams and streamers with zero viewers</title>
    <link rel="stylesheet" href="/static/styles.css?cache_bust=0.0.1" type="text/css">
    <link rel="stylesheet" href="/static/modal.css" type="text/css">

    <link rel="preconnect" href="https://embed.twitch.tv">
    <link rel="preconnect" href="https://static-cdn.jtvnw.net">
    <link rel="preconnect" href="https://p.twitchcdn.net">
    <link rel="preconnect" href="https://static.twitchcdn.net">
    <link rel="preconnect" href="https://gql.twitch.tv">
  </head>
  <body>
    <div id="page-container">
      <div id="motd" class="motd"></div>
      <div class="grid-container">
        <div class="left-pane hide-on-minimal">
          <h1>nobody.live</h1>
          <span>streams with <span id="debug-trigger">nobody</span> watching <span id="debug-menu" class="hidden"> | <a id="stream-debug" href="#">show stream debug</a> | <a href="/static/stats.html" target="_blank">show site stats</a></span></span>
        </div>
        <div class="right-pane">
          <button id="new-streamer-button" data-message="new streamer" disabled>please wait... </button><br />
          <button class="fake-link filter" id="filter" data-micromodal-trigger="filter-modal">filters & settings</button>
        </div>
      </div>
      <div id="twitch-embed-wrapper" class="container">
        <div id="twitch-embed"></div>
        <div class="even-grid-container hide-on-minimal">
          <div class="even-left-pane">
            <p class="stream_duration_container">Stream online for <span id="stream_duration"></span>.</p>
          </div>
          <div class="even-right-pane">
            <p class="cookie-check">Trouble logging into chat? Try enabling third party cookies.</p>
          </div>
        </div>
      </div>
      <div class="thumbnails container center-text hide-on-minimal">
        <button class="new-thumbnails fake-link">Get new thumbnails</button><img src="/static/tetris_dx_throbber.min.svg" width="38" height="38" class="loading-throbber invisible"></img>
        <div id="thumbnails" class="thumbnail-container"></div>
        <button class="new-thumbnails fake-link">Get new thumbnails</button><img src="/static/tetris_dx_throbber.min.svg" width="38" height="38" class="loading-throbber invisible"></img>
      </div>
      <div class="hide-on-minimal" id="footer">
        watched streams: <span id="stream-list"></span>
        <br><br>
        made with <a href="https://github.com/jkingsman/Nobody.live" target="_blank" rel="noopener">open source</a> and love by jack kingsman, with much appreciation for carsten hoffrichter's <i>lonely streams</i>
        <br><br>
        this site is free, and ad-free, forever; <a href="https://ko-fi.com/jackkingsman" target="_blank" rel="noopener">donations to help offset server costs</a> are much appreciated :)
      </div>
    </div>

    <div class="modal micromodal-slide" id="filter-modal" aria-hidden="true">
      <div class="modal__overlay" tabindex="-1" data-micromodal-close>
        <div class="modal__container" role="dialog" aria-modal="true" aria-labelledby="filter-modal-title">
          <header class="modal__header">
            <h2 class="modal__title" id="filter-modal-title">
              Filter Streams
            </h2>
            <button class="modal__close" aria-label="Close modal" data-micromodal-close></button>
          </header>
          <form id="search-form">
            <main class="modal__content">
              <div class="options-columns">
                <label for="include" class="search-input">Search phrase:</label> <input class="search-input" type="text" id="include">
                <span class="grid-right field-config">
                  <span class="nobreak">
                    <input type="radio" id="search_all" name="search_operator" value="all" checked>
                    <label for="search_all">Match ALL terms</label>
                  </span>
                  <span class="nobreak">
                    <input type="radio" id="search_any" name="search_operator" value="any">
                    <label for="search_any">Match ANY term</label>
                  </span>
                  <span class="grid-right field-description">Search includes games and tags<br>(e.g. <code>mario</code> or <code>speedrun</code> or <code>korea</code>)</span>
                </span>

                <label for="exclude" class="search-input options-spacer">Exclude Keywords:</label> <input class="search-input options-spacer" type="text" id="exclude">
                <span class="grid-right field-description">Exclude games/categories containing <strong>any</strong> of these terms (separate with spaces)</span>

                <span class="grid-right field-config options-spacer"><input type="checkbox" id="remember"><label for="remember">Remember my filters</label></span>
              </div>
              <hr>
              <details>
                <summary>Advanced Stream Search</summary>
                <div class="options-columns">
                  <label for="min-age" class="search-input">Min. duration:</label>
                  <select id="min-age">
                    <option value="0">Show all streams</option>
                    <option value="3">Only show &gt;3 minutes on-air</option>
                    <option value="5">Only show &gt;5 minutes on-air</option>
                    <option value="10">Only show &gt;10 minutes on-air</option>
                  </select>
                  <span class="grid-right field-description">Avoid streams in "starting soon" mode by hiding streams which have just started.</span>

                  <span class="grid-right field-config"><input type="checkbox" id="show_singles"><label for="show_singles">Include streams with one viewer</label></span>
                </div>
                <hr>
              </details>
              <details>
                <summary>Interface Customization</summary>
                <div class="options-columns">
                  <span class="grid-span field-config"><input type="checkbox" id="wide_page"><label for="wide_page">Wide page</label></span>
                  <span class="grid-span field-config"><input type="checkbox" id="minimal_page"><label for="minimal_page">Minimal page</label></span>
                </div>
              </details>
            </main>
            <footer class="modal__footer">
              <button class="modal__btn modal__btn-primary" data-micromodal-close aria-label="Save filter" id="save-filter" type="submit">Save & Apply</button>
            </footer>
          </form>
        </div>
      </div>
    </div>

    <script src="https://embed.twitch.tv/embed/v1.js"></script>
    <script src="/static/micromodal.min.js"></script>
    <script>
      /* global Twitch, MicroModal */
      /* eslint no-alert: "off", no-new: "off", no-param-reassign: "off" */
      MicroModal.init();

      let numberOfThumbnailsToFetch = 16;
      const server = document.location.origin;
      let currentStream; // holds JSON blob of currently displayed stream

      const SETTINGS = {
        shouldRemember: {
          respectsRememberSetting: false,
          default: false,
          allowedValues: [true, false],
        },
        include: {
          respectsRememberSetting: true,
          default: '',
        },
        exclude: {
          respectsRememberSetting: true,
          default: '',
        },
        minDuration: {
          respectsRememberSetting: true,
          default: 0,
          allowedValues: [0, 3, 5, 10],
        },
        maxViewers: {
          respectsRememberSetting: true,
          default: 0,
          allowedValues: [0, 1],
        },
        searchOperator: {
          respectsRememberSetting: true,
          default: 'all',
          allowedValues: ['all', 'any'],
        },
        widePage: {
          respectsRememberSetting: false,
          default: false,
          allowedValues: [true, false],
        },
        minimalPage: {
          respectsRememberSetting: false,
          default: false,
          allowedValues: [true, false],
        },
        streamHistory: {
          respectsRememberSetting: false,
          default: '[]',
        },
      };

      function getStoredSetting(settingKey, parse = false) {
        // check that we know about the setting
        if (!SETTINGS[settingKey]) {
          console.error(`Unknown key! ${settingKey} is not one of ${Object.keys(SETTINGS).join(', ')}`);
          return null;
        }

        const requestedSetting = SETTINGS[settingKey];

        // check if we have a stored value
        if (localStorage.getItem(settingKey) === null) {
          // key doesn't exist
          localStorage.setItem(settingKey, requestedSetting.default);
        }

        let rawSetting;
        if (requestedSetting.respectsRememberSetting) {
          if (JSON.parse(localStorage.getItem('shouldRemember')) || false) {
            // this respects the remember setting, and we should use the remembered value
            rawSetting = localStorage.getItem(settingKey);
          } else {
            // this respects the remember setting, but we are not set to remember right now
            // give the default
            return requestedSetting.default;
          }
        } else {
          // doesn't respect remember setting; provide what's in storage
          rawSetting = localStorage.getItem(settingKey);
        }

        if (parse) {
          try {
            return JSON.parse(rawSetting);
          } catch (error) {
            console.error(`Parse failure! Could not parse key '${settingKey}' with value '${rawSetting}'.`);
            return rawSetting;
          }
        } else {
          return rawSetting;
        }
      }

      function setStoredSetting(settingsObj) {
        for (const [settingKey, value] of Object.entries(settingsObj)) {
          // check that we know about the setting
          if (!SETTINGS[settingKey]) {
            console.error(`Unknown key! ${settingKey} is not one of ${Object.keys(SETTINGS).join(', ')}`);
            return;
          }

          const requestedSetting = SETTINGS[settingKey];
          if (requestedSetting.allowedValues && !requestedSetting.allowedValues.includes(value)) {
            console.error(`Illegal value! '${value}' is not one of ${requestedSetting.allowedValues.join(', ')}`);
            return;
          }

          const shouldRemember = JSON.parse(localStorage.getItem('shouldRemember')) || false;
          if (requestedSetting.respectsRememberSetting) {
            if (shouldRemember) {
              // this respects the remember setting, and we should set the remembered value
              localStorage.setItem(settingKey, value);
            } else {
              // this respects the remember setting, but we are not set to remember right now so store default
              localStorage.setItem(settingKey, requestedSetting.default);
            }
          } else {
            // doesn't respect remember setting; store what we're given
            localStorage.setItem(settingKey, value);
          }
        }
      }

      // create a nice single string to describe the search ('<include terms> not:<exclude> not:<terms>')
      function generateFilterString() {
        const excludeString = document.getElementById('exclude').value.trim().split(' ').map((term) => (term ? `not:${term}` : '')).join(' ');
        const timeString = Number(document.getElementById('min-age').value) > 0 ? `â±>${document.getElementById('min-age').value}m` : '';

        return `${document.getElementById('include').value.trim()} ${excludeString} ${timeString}`.trim();
      }

      // note that this uses the form data so we can ignore the "remember" button
      async function getStreams(count = 1) {
        const streamEndpoint = new URL('/stream', server);
        streamEndpoint.searchParams.set('count', count);
        streamEndpoint.searchParams.set('include', document.getElementById('include').value.trim());
        streamEndpoint.searchParams.set('exclude', document.getElementById('exclude').value.trim());
        streamEndpoint.searchParams.set('min_age', Number(document.getElementById('min-age').value));
        streamEndpoint.searchParams.set('max_viewers', document.getElementById('show_singles').checked ? 1 : 0);
        streamEndpoint.searchParams.set(
          'search_operator',
          document.querySelector('input[name="search_operator"]:checked').value,
        );

        const streamResponse = await fetch(streamEndpoint.href);
        if (streamResponse.status === 503) {
          alert('You\'re doing that too much! Please slow down.');
          return false;
        }

        if (streamResponse.status >= 400) {
          alert('Search error! Please use a shorter search phrase.');
          MicroModal.show('filter-modal');
          return false;
        }

        const streamJson = await streamResponse.json();
        if (streamJson.length === 0) {
          alert(`Uh oh! No streams found. Please broaden your filter (currently '${generateFilterString()}').`);
          MicroModal.show('filter-modal');
          return false;
        }
        return streamJson;
      }

      function setStreamRuntime() {
        // show stream runtime
        const streamRuntime = new Date() - new Date(currentStream.started_at);
        let streamRuntimeMinutes = Math.round(streamRuntime / (1000 * 60));
        const streamRuntimeHours = Math.floor(streamRuntimeMinutes / 60);
        streamRuntimeMinutes -= (streamRuntimeHours * 60);

        let streamRuntimeString = '';
        if (streamRuntimeHours > 0) {
          streamRuntimeString += `${streamRuntimeHours}hr`;
        }

        if (streamRuntimeMinutes > 0) {
          streamRuntimeString += `${streamRuntimeMinutes}min`;
        }

        if (streamRuntimeMinutes === 0 && streamRuntimeHours === 0) {
          streamRuntimeString += 'no time at all';
        }

        document.getElementById('stream_duration').innerText = streamRuntimeString;
      }

      // performs stream fetch/new streamer button timeout
      // accepts an optional stream object if streams have been prefetched
      async function renderStream(stream) {
        if (Array.isArray(stream)) {
          // we were given an array; no biggy -- just pop the first off
          stream = stream[0];
        }

        // disables the new streamer button, then reenables after 2 seconds
        document.getElementById('new-streamer-button').disabled = true;
        document.getElementById('new-streamer-button').innerText = 'please wait...';
        setTimeout(() => {
          const newButton = document.getElementById('new-streamer-button');
          newButton.disabled = false;
          newButton.innerText = newButton.getAttribute('data-message');
        }, 3000);

        currentStream = stream || (await getStreams(1))[0];
        if (!currentStream) {
          // probably got rate limited or no results; bail out
          return;
        }

        // clear and rerender the embed div
        document.getElementById('twitch-embed').innerHTML = '';
        new Twitch.Embed('twitch-embed', {
          width: '100%',
          channel: currentStream.user_name,
          theme: 'dark',
          parent: [window.location.hostname],
        });

        // load and append stream to historical streams
        const usernames = getStoredSetting('streamHistory', true);
        usernames.push(currentStream.user_name);
        const trimmedUsernames = usernames.slice(-5);
        setStoredSetting({
          streamHistory: JSON.stringify(trimmedUsernames),
        });

        // rerender list of historical streams
        document.getElementById('stream-list').innerHTML = trimmedUsernames.map((username) => {
          const a = document.createElement('a');
          const linkText = document.createTextNode(username);
          a.appendChild(linkText);
          a.href = `https://www.twitch.tv/${username}`;
          a.target = '_blank';
          a.rel = 'noopener';

          return a.outerHTML;
        }).join(', ');

        // render runtime
        setStreamRuntime();
      }

      // fetches a given number of thumbnails and renders them into view
      // accepts an optional list of streams to draw from instead of making an API call
      async function renderThumbnails(streamList) {
        const container = document.getElementById('thumbnails');

        // if this is not our first load, lock elem height so there's no reflow as we load new ones
        if (container.childNodes.length !== 0) {
          container.style.height = `${container.offsetHeight}px`;
        }

        // hide button until we're done, and reinstate and the end
        document.querySelectorAll('.new-thumbnails').forEach((button) => button.classList.add('hidden'));
        document.querySelectorAll('.loading-throbber').forEach((throbber) => throbber.classList.remove('invisible'));

        container.innerHTML = '';

        streamList.forEach((stream) => {
          // embed inside of an a element so you can ctrl+click to open in a new tab
          const a = document.createElement('a');
          a.href = `${window.location.origin}/?stream=${encodeURIComponent(JSON.stringify(stream))}`;
          // override the default so on-page clicks just run the render code
          a.onclick = (event) => {
            if (!event.ctrlKey && !event.metaKey) {
              event.preventDefault();
              renderStream(stream);

              document.body.scrollTop = 0; // For Safari
              document.documentElement.scrollTop = 0; // For Chrome, Firefox, IE and Opera
            }
          };
          a.rel = 'noopener';

          const thumb = document.createElement('img');
          thumb.className = 'thumbnail-item';
          thumb.alt = `${stream.user_name}: ${stream.title || '[No title]'}`;
          thumb.title = thumb.alt;
          thumb.src = stream.thumbnail_url.replace('{width}', '440').replace('{height}', '248');

          a.appendChild(thumb);
          container.appendChild(a);
        });

        // restore any height locking we did after the thumbs have had a chance to load
        setTimeout(() => { container.style.height = 'auto'; }, 2000);

        // restore our button listener from our debounce with a bit of rate limit delay
        setTimeout(() => {
          document.querySelectorAll('.new-thumbnails').forEach((button) => button.classList.remove('hidden'));
          document.querySelectorAll('.loading-throbber').forEach((throbber) => throbber.classList.add('invisible'));
        }, 2000);
      }

      // populates the filter UI, executes UI changes if needed for UI experiment settings,
      // and sets thumbnail + new streamer button text if a filter is set
      function populateFilterFormFromStorage() {
        // set search form with values from storage
        document.getElementById('remember').checked = getStoredSetting('shouldRemember', true);
        document.getElementById('include').value = getStoredSetting('include');
        document.getElementById('exclude').value = getStoredSetting('exclude');
        document.getElementById('min-age').value = getStoredSetting('minDuration', true);
        document.getElementById('show_singles').checked = getStoredSetting('maxViewers', true) === 1;

        document.getElementById('search_all').checked = getStoredSetting('searchOperator') === 'all';
        document.getElementById('search_any').checked = getStoredSetting('searchOperator') === 'any';
      }

      function setInterfaceCustomizationFromStorage() {
        // set UI customization values and add/remove the classes
        const isWidePageSet = getStoredSetting('widePage', true);
        document.getElementById('wide_page').checked = isWidePageSet;
        if (isWidePageSet) {
          document.body.classList.add('wide');
        } else {
          document.body.classList.remove('wide');
        }

        const isMinimalPageSet = getStoredSetting('minimalPage', true);
        document.getElementById('minimal_page').checked = isMinimalPageSet;
        if (isMinimalPageSet) {
          document.body.classList.add('minimal');
        } else {
          document.body.classList.remove('minimal');
        }
      }

      function setButtonTextWithFilterDataFromForm() {
        const streamButton = document.getElementById('new-streamer-button');
        if (!document.getElementById('include').value.trim()
              && !document.getElementById('exclude').value.trim()
              && Number(document.getElementById('min-age').value) === 0
        ) {
          // we have no filter active; restore things to normal text
          document.querySelectorAll('.new-thumbnails').forEach((button) => {
            button.innerText = 'Get new thumbnails';
          });
          document.querySelector('#filter').innerText = 'filters & settings';

          // always set when-enabled text, but only bother with setting actual text if it's active
          document.getElementById('new-streamer-button').setAttribute('data-message', 'new streamer');
          if (!streamButton.disabled) {
            document.getElementById('new-streamer-button').innerText = 'new streamer';
          }
        } else {
          // we have filters to display
          const searchString = generateFilterString();

          // set thumbnail text, filter status, and new streamer button text
          document.querySelectorAll('.new-thumbnails').forEach((button) => {
            button.innerText = `Get new thumbnails ('${searchString}')`;
          });
          document.querySelector('#filter').innerText = 'filter active';
          document.getElementById('new-streamer-button').setAttribute(
            'data-message',
            `new streamer ('${searchString}')`,
          );

          if (!streamButton.disabled) {
            document.getElementById('new-streamer-button').innerText = `new streamer ('${searchString}')`;
          }
        }
      }

      // called after the filter form is updated and persists or clears filters to localstorage
      // returns whether or not the new criteria is different enough to require a reload of thumbs + stream
      async function setStorageFromForm(e) {
        const include = document.getElementById('include').value.trim();
        const exclude = document.getElementById('exclude').value.trim();
        const shouldRemember = document.getElementById('remember').checked;

        const shouldReload = getStoredSetting('include') !== include
               || getStoredSetting('exclude') !== exclude;

        // shouldRemeber always needs to go first so include/exclude/etc. get saved
        setStoredSetting({
          shouldRemember,
          include,
          exclude,
          maxViewers: document.getElementById('show_singles').checked ? 1 : 0,
          searchOperator: document.querySelector('input[name="search_operator"]:checked').value,
        });

        return shouldReload;
      }

      // write form information to storage, update the UI as needed, and possibly refresh stream/thumbs
      async function handleFormChange(e) {
        if (e) {
          e.preventDefault();
        }

        const shouldReload = setStorageFromForm();
        setInterfaceCustomizationFromStorage();
        setButtonTextWithFilterDataFromForm();

        // load new streams and thumbs if the criteria has changed or if we have no current stream
        // (no current stream means we got no results for the last query, so let's try again)
        if (shouldReload || !currentStream) {
          const fetchedStreams = await getStreams(numberOfThumbnailsToFetch + 1);
          if (fetchedStreams) {
            renderStream(fetchedStreams[0]);
            renderThumbnails(fetchedStreams.slice(1));
          }
        }
      }

      async function enableDebug() {
        document.getElementById('debug-menu').classList.remove('hidden');
        const debugButton = document.getElementById('stream-debug');
        debugButton.addEventListener('click', () => {
          window.open(`${server}/stream/${currentStream.id}`, '_blank');
        });

        debugButton.addEventListener('touchstart', () => {
          window.open(`${server}/stream/${currentStream.id}`, '_blank');
        });
        numberOfThumbnailsToFetch = 64;
      }

      function immediateToggleInterfaceCustomization(settingsKey) {
        const settingsObj = {};
        settingsObj[settingsKey] = !getStoredSetting(settingsKey, true);
        setStoredSetting(settingsObj);
        setInterfaceCustomizationFromStorage();
      }

      async function initPage() {
        // hook up all event listeners
        document.getElementById('new-streamer-button').addEventListener(
          'click',
          async () => renderStream(await getStreams(1)),
        );
        document.getElementById('save-filter').addEventListener('click', handleFormChange);
        document.getElementById('save-filter').addEventListener(
          'touchstart',
          handleFormChange,
          { passive: true },
        );
        document.getElementById('search-form').addEventListener('submit', handleFormChange);
        document.getElementById('wide_page').addEventListener(
          'change',
          () => immediateToggleInterfaceCustomization('widePage', 'wide'),
        );
        document.getElementById('minimal_page').addEventListener(
          'change',
          () => immediateToggleInterfaceCustomization('minimalPage', 'minimal'),
        );
        document.querySelectorAll('.new-thumbnails').forEach((button) => button.addEventListener(
          'click',
          async () => renderThumbnails(await getStreams(numberOfThumbnailsToFetch)),
        ));
        document.getElementById('debug-trigger').addEventListener('click', enableDebug);
        document.getElementById('debug-trigger').addEventListener('touchstart', enableDebug, { passive: true });

        // populate buttons/filter UI/etc.
        populateFilterFormFromStorage();
        setInterfaceCustomizationFromStorage();
        setButtonTextWithFilterDataFromForm();

        // prefetch 17 thumbs (main + 16 thumbnails)
        const fetchedStreams = await getStreams(numberOfThumbnailsToFetch + 1);

        // if we have /?stream=... then render the specified stream
        // otherwise grab a random one
        const urlParams = new URLSearchParams(window.location.search);
        if (urlParams.has('stream')) {
          renderStream(JSON.parse(urlParams.get('stream')));
          window.history.pushState({}, document.title, window.location.pathname);
        } else if (urlParams.has('force')) {
          renderStream({
            user_name: urlParams.get('force'),
            id: `forcedstream-${urlParams.get('force')}`,
            started_at: new Date().toISOString(),
          });
        } else if (fetchedStreams) {
          renderStream(fetchedStreams[0]);
          setInterval(setStreamRuntime, 30000);
        }

        if (fetchedStreams) {
          // render thumbs using the rest of the prefetch
          renderThumbnails(fetchedStreams.slice(1));
        }

        // MOTD display
        const motd = await fetch(`${server}/static/motd?cachebust=${Date.now()}`);
        // only render if one exists
        if (motd.status === 200) {
          const motdText = await motd.text();
          document.getElementById('motd').innerHTML = motdText;
        }

        // note we can hit the end of this block with no stream running if our search params turned up nothing
      }

      initPage();
    </script>
  </body>
</html>
